// Package models contains the types for schema 'public'.
package models

// GENERATED BY XO. DO NOT EDIT.

import (
	"errors"
)

// Match represents a row from 'public.matches'.
type Match struct {
	ID         int    `json:"id"`           // id
	HomeTeam   string `json:"home_team"`    // home_team
	AwayTeam   string `json:"away_team"`    // away_team
	HomeUserID int    `json:"home_user_id"` // home_user_id
	AwayUserID int    `json:"away_user_id"` // away_user_id
	HomePoints int    `json:"home_points"`  // home_points
	AwayPoints int    `json:"away_points"`  // away_points

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Match exists in the database.
func (m *Match) Exists() bool {
	return m._exists
}

// Deleted provides information if the Match has been deleted from the database.
func (m *Match) Deleted() bool {
	return m._deleted
}

// Insert inserts the Match to the database.
func (m *Match) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO public.matches (` +
		`home_team, away_team, home_user_id, away_user_id, home_points, away_points` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints)
	err = db.QueryRow(sqlstr, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints).Scan(&m.ID)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Update updates the Match in the database.
func (m *Match) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if m._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.matches SET (` +
		`home_team, away_team, home_user_id, away_user_id, home_points, away_points` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE id = $7`

	// run query
	XOLog(sqlstr, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints, m.ID)
	_, err = db.Exec(sqlstr, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints, m.ID)
	return err
}

// Save saves the Match to the database.
func (m *Match) Save(db XODB) error {
	if m.Exists() {
		return m.Update(db)
	}

	return m.Insert(db)
}

// Upsert performs an upsert for Match.
//
// NOTE: PostgreSQL 9.5+ only
func (m *Match) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if m._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.matches (` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.home_team, EXCLUDED.away_team, EXCLUDED.home_user_id, EXCLUDED.away_user_id, EXCLUDED.home_points, EXCLUDED.away_points` +
		`)`

	// run query
	XOLog(sqlstr, m.ID, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints)
	_, err = db.Exec(sqlstr, m.ID, m.HomeTeam, m.AwayTeam, m.HomeUserID, m.AwayUserID, m.HomePoints, m.AwayPoints)
	if err != nil {
		return err
	}

	// set existence
	m._exists = true

	return nil
}

// Delete deletes the Match from the database.
func (m *Match) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !m._exists {
		return nil
	}

	// if deleted, bail
	if m._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.matches WHERE id = $1`

	// run query
	XOLog(sqlstr, m.ID)
	_, err = db.Exec(sqlstr, m.ID)
	if err != nil {
		return err
	}

	// set deleted
	m._deleted = true

	return nil
}

// GetAllMatchs returns paginated most recent rows from 'public.matches',
// ordered by "created_at" in descending order.
func GetAllMatchs(db XODB, page, resultsPerPage int) ([]*Match, error) {
	startIndex := (page - 1) * resultsPerPage
	const sqlstr = `SELECT ` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points ` +
		`FROM public.matches ` +
		`ORDER BY created_at DESC LIMIT $1 OFFSET $2`

	q, err := db.Query(sqlstr, resultsPerPage, startIndex)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Match
	for q.Next() {
		m := Match{}

		// scan
		err = q.Scan(&m.ID, &m.HomeTeam, &m.AwayTeam, &m.HomeUserID, &m.AwayUserID, &m.HomePoints, &m.AwayPoints)
		if err != nil {
			return nil, err
		}

		res = append(res, &m)
	}

	return res, nil
}

// GetMostRecentMatchs returns n most recent rows from 'public.matches',
// ordered by "created_at" in descending order.
func GetMostRecentMatchs(db XODB, n int) ([]*Match, error) {
	const sqlstr = `SELECT ` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points ` +
		`FROM public.matches ` +
		`ORDER BY created_at DESC LIMIT $1`

	q, err := db.Query(sqlstr, n)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Match
	for q.Next() {
		m := Match{}

		// scan
		err = q.Scan(&m.ID, &m.HomeTeam, &m.AwayTeam, &m.HomeUserID, &m.AwayUserID, &m.HomePoints, &m.AwayPoints)
		if err != nil {
			return nil, err
		}

		res = append(res, &m)
	}

	return res, nil
}

// UserByAwayUserID returns the User associated with the Match's AwayUserID (away_user_id).
//
// Generated from foreign key 'matches_away_user_id_fk'.
func (m *Match) UserByAwayUserID(db XODB) (*User, error) {
	return UserByID(db, m.AwayUserID)
}

// UserByHomeUserID returns the User associated with the Match's HomeUserID (home_user_id).
//
// Generated from foreign key 'matches_home_user_id_fk'.
func (m *Match) UserByHomeUserID(db XODB) (*User, error) {
	return UserByID(db, m.HomeUserID)
}

// MatchesByAwayUserID retrieves a row from 'public.matches' as a Match.
//
// Generated from index 'matches_away_user_id_idx'.
func MatchesByAwayUserID(db XODB, awayUserID int) ([]*Match, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points ` +
		`FROM public.matches ` +
		`WHERE away_user_id = $1`

	// run query
	XOLog(sqlstr, awayUserID)
	q, err := db.Query(sqlstr, awayUserID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Match{}
	for q.Next() {
		m := Match{
			_exists: true,
		}

		// scan
		err = q.Scan(&m.ID, &m.HomeTeam, &m.AwayTeam, &m.HomeUserID, &m.AwayUserID, &m.HomePoints, &m.AwayPoints)
		if err != nil {
			return nil, err
		}

		res = append(res, &m)
	}

	return res, nil
}

// MatchesByHomeUserID retrieves a row from 'public.matches' as a Match.
//
// Generated from index 'matches_home_user_id_idx'.
func MatchesByHomeUserID(db XODB, homeUserID int) ([]*Match, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points ` +
		`FROM public.matches ` +
		`WHERE home_user_id = $1`

	// run query
	XOLog(sqlstr, homeUserID)
	q, err := db.Query(sqlstr, homeUserID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Match{}
	for q.Next() {
		m := Match{
			_exists: true,
		}

		// scan
		err = q.Scan(&m.ID, &m.HomeTeam, &m.AwayTeam, &m.HomeUserID, &m.AwayUserID, &m.HomePoints, &m.AwayPoints)
		if err != nil {
			return nil, err
		}

		res = append(res, &m)
	}

	return res, nil
}

// MatchByID retrieves a row from 'public.matches' as a Match.
//
// Generated from index 'matches_pkey'.
func MatchByID(db XODB, id int) (*Match, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, home_team, away_team, home_user_id, away_user_id, home_points, away_points ` +
		`FROM public.matches ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	m := Match{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&m.ID, &m.HomeTeam, &m.AwayTeam, &m.HomeUserID, &m.AwayUserID, &m.HomePoints, &m.AwayPoints)
	if err != nil {
		return nil, err
	}

	return &m, nil
}
